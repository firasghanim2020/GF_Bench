\section{Introduction}

% Use for TCOMP
\IEEEPARstart{I}{mportance} of arithmetic verification problem grows with an increased use of arithmetic modules in embedded systems to perform computation-intensive tasks in multimedia, signal processing, and cryptography applications. 
One of the remaining challenges in formal verification is formal verification of gate-level integer arithmetic circuits, such as multipliers, used extensively in those applications. Despite a considerable progress in verification of random and control logic, advances in formal verification of arithmetic designs have been slow. This can be attributed to the difficulty in the efficient modeling of arithmetic circuits and datapaths without resorting to computationally expensive Boolean methods, such as BDDs, SAT, SMT, etc., that require ``bit blasting'', i.e., flattening the design to a bit-level netlist. However, recently, formal techniques based on \textit{computer algebra} have been successfully applied to the verification problems of gate-level arithmetic circuits.

Computer algebra techniques, which construct the polynomial representation of a gate-level arithmetic circuit, are believed to offer best solution for analyzing arithmetic circuits \cite{ciesielski2015verification}\cite{kalla:tcad13}\cite{STABLE:date11}\cite{sayedformal:date-2016}. These works address the verification problems of Galois field arithmetic and integer arithmetic implementations, including abstractions and reverse engineering \cite{STABLE:date11}\cite{sayedformal:date-2016}\cite{ciesielski2015verification}. The verification problem is typically formulated as a proof that the implementation satisfies the specification, which is solved by polynomial division or algebraic rewriting. The results show that the computer algebra techniques provide several orders of magnitude performance improvement. The main advantage of computer algebra methods for verifying arithmetic circuits is that it provides a large number of polynomial reductions (by eliminating non-linear terms) while applying those techniques to a binary encoded specification polynomial. For example, let a polynomial expression be $E$ = $2x_1$ + $a + b - 2ab$, where $x_1$ is an output of an AND2 gate with inputs $a$ and $b$. After rewriting the algebraic model of AND2($a, b$) = $ab$, $E$ = $2ab + a + b - 2ab$ = $a + b$. We can see that the non-linear term $ab$ has been eliminated. Note that non-linear terms could explode exponentially after rewriting the variables in that term if they were not eliminated at the right time (order).

The order of rewriting or performing polynomial divisions has a significant impact on the performance of the computer algebra techniques \cite{sayedformal:date-2016}\cite{yu:2016-tcad-verification}. However, computer algebra techniques may fail to find an efficient order of nodes in the gate-level arithmetic circuits. The main reason is that these techniques are applied to the original netlist. Yu et al. \cite{yu:2016-tcad-verification} compared the performance of algebraic methods on combinational gate-level multipliers when different topological orders are used. It showed that an efficient topological order may not exist in the post-synthesized gate-level netlist. Even if such an order exists, it may be difficult to identify because of the polynomial reductions hidden in the complex standard cells. In addition, redundant polynomials detected from combinational and sequential arithmetic circuits can provide significant polynomial reductions \cite{yu-isvlsi-16a}. However, detecting such polynomials is limited by manual operations and depends on the structure of the circuits.

The approach presented in this paper aims at improving the efficiency of algebraic rewriting in the context of arithmetic verification. It addresses the problem by using a compact and uniform representation of the Boolean network called the \textit{And-Inverter Graph} (AIG) \cite{mishchenko:2006-dag}. Algebraic rewriting is performed by deriving the arithmetic function of the circuit from its low-level circuit representation. Instead of directly applying algebraic rewriting to the gate-level netlist, it is applied to an AIG. Additionally, this approach allows to automatically generate redundant polynomials, which significantly reduce the complexity of algebraic rewriting. 


%--------------

%This paper describes the functional verification problem for sequential integer arithmetic circuits. 

%Sequential, bit/word-serial arithmetic circuits remain a more challenging verification problem since the function depends on combinational function and the states. In such circuits, the input is provided serially, either on a single-bit line or as as word-level vector, and the result is collected over a number of cycles to produce an $n$-bit (or word-level) result. The goal is to prove that the circuit computes the required arithmetic function collected sequentially at the primary outputs.
%Even though functional verification of such arithmetic circuits can be cast as a combinational bounded model problem, it is still challenging due to a large number of bits in practical arithmetic circuits. 

%An example of the type of circuits considered here is shown in Figure \ref{fig:serial-adder}. It is an $n$-bit serial adder built out of a single-bit adder, which operates for $n$ clock cycles to produce an ($n$+1)-bit result. An equivalent combinational model is obtained by unrolling the adder $n$ times. The proof of functional correctness consists in transforming the polynomial associated with the result $ Z = z_o+2^{1}z_{1}+ \cdots 2^nz_{n}$
%$Z = \sum_{i=0}^{i=n-1} 2^{i} z_{i}$ 
%into a polynomial expressed in primary inputs, $\{a_i\}, \{b_i\}$, applied to the circuit serially; and checking if this polynomial indeed represents the addition of two input operands: 
%$Z = A+B = (a_o+2^{1}a_1+ \cdots 2^{n-1}a_{n-1}) + (b_o+2^{1}b_1+ \cdots 2^{n-1}b_{n-1})$.
%However, as demonstrated in the paper, such a straightforward unrolling may be inefficient from the verification point of view, and special techniques are needed to make it effective and scalable. Those techniques are the main focus of this paper. 




%\begin{figure}[htb] 
%\begin{center}
%\includegraphics[scale=0.5]{../figs/intro-sequential-fa.eps}
%\caption{Sequential $n$-bit adder, $Z = A+B $.}
%\label{fig:serial-adder}
%\end{center}
%\end{figure}

%------------------


