13c13
< This section presents the algebraic rewriting approach based on AIGs. Similarly to \cite{ciesielski2015verification}, the algebraic rewriting process rewrites the output signature for all AIG nodes in a topological order. As discussed in Section \rom{3}-E, the rewriting order that provides a large number of polynomial reductions, has significant impact on the performance of rewriting. However, there are many topological orders available in an AIG, since many nodes can have the same topological depth. This approach detects a topological order for algebraic rewriting that provides the maximum polynomial reduction. This is achieved by detecting pairs of MAJ3 and XOR3 nodes using AIG-based \textit{cut enumeration}. 
---
> This section presents the algebraic rewriting approach based on AIG. Similarly to \cite{ciesielski2015verification}, the algebraic rewriting process rewrites the output signature through all the nodes in the AIG in a topological order. As discussed in Section \rom{3}-E, the rewriting order that provides a large number of polynomial reductions, has significant impact on the performance of rewriting. However, there are many topological orders available in an AIG, since many nodes can have the same topological depth. This approach detects a topological order for algebraic rewriting that provides the maximum polynomial reductions. This is achieved by searching the pairs of MAJ3 and XOR3 nodes by computing the AIG \textit{Cuts}. 
44c44
< The proposed flow is outlined in Algorithm 1. The inputs to the algorithm are: the gate-level netlist and the output signature $Sig_{out}$. The flow includes three basic steps: 1) converting the gate-level implementation into AIG; 2) detecting all pairs of XOR3 and MAJ3 nodes with identical inputs; topological sorting the AIG nodes while considering the detected pairs as one element; and 3) applying algebraic rewriting from POs to PIs following the topological order determined in step 2). Note that XOR2 and MAJ2(AND2) are the special cases of XOR3 and MAJ3, where one of the inputs is constant zero. The second step is performed as follows: 
---
> The proposed flow is outlined in Algorithm 1. The inputs to the algorithm are: the gate-level netlist and the output signature $Sig_{out}$. The flow includes three basic steps: 1) convert the gate-level implementation into AIG; 2) detect all pairs of XOR3 and MAJ3 nodes with identical inputs; topologically sort the AIG nodes while considering the detected pairs as one element; and 3) apply algebraic rewriting from POs to PIs following the topological order determined in step 2. Note that XOR2 and MAJ2(AND2) are the special cases of XOR3 and MAJ3, where one of the inputs is constant zero. The second step specifically processes as follows: 
48c48
< \item Computing all 3-feasible (3-input) cuts of all AIG nodes.
---
> \item Compute all 3-feasible (3-input) cuts of all AIG nodes.
50c50
< \item Computing truth tables of all cuts.
---
> \item Compute truth tables of all cuts.
52c52
< \item Storing cuts in the hash table by their ordered set of inputs.
---
> \item Store the cuts in the hash table by their ordered set of inputs.
54c54
< \item Detecting pairs of 3-input cuts with identical inputs belonging to different nodes, such that the Boolean functions of the two cuts with the shared inputs belong to the \textit{NPN} classes of XOR3 and MAJ3, respectively.
---
> \item Find pairs of 3-input cuts with identical inputs w.r.t to different nodes, such that the Boolean functions of the two cuts with the shared inputs are in \textit{NPN} classes of XOR3 and MAJ3, respectively.
58c58
< Note that, in this approach, matching the XOR3 and MAJ3 nodes does not require the inputs and outputs polarity to be the same. Instead, all the cut-points are matched without considering their complemented attributes. For example, instead of being an exact XOR3, the function of a 3-feasible cut can be either XOR3 or XNOR3. Similarly, instead of being exactly MAJ3, the function of can be one of the eight functions forming the \textit{NPN} class of MAJ3 \cite{HuangWNM13}. To compute the cuts, the 3-input cut enumeration is performed in a topological order as described in \cite{PanL98}. The truth tables of the cuts are obtained as a by-product of the cut enumeration. Thus, when two fanin cuts are merged during the cut computation and the resulting cut is 3-feasible, the truth tables of fanin cuts are permuted to match the fanin order of the resulting cut. These truth tables are then ANDed or XORed, depending on the node type, to get the resulting truth table. For the case of 3-input cuts, a dedicated pre-computation reduces the runtime of truth table computation to a small fraction of that of cut enumeration.
---
> Note that, in this approach, matching the XOR3 and MAJ3 nodes do not require the inputs and outputs polarity to be the same. Instead, all the cut-points are matched without considering the complement. For example, instead of being an exact XOR3, the function of a 3-feasible cut can be either XOR3 or XNOR3. Similarly, instead of being exactly MAJ3, the function of can be one of the eight functions forming the \textit{NPN} class of MAJ3 \cite{HuangWNM13}. To compute the cuts, the 3-input cut enumeration is performed in a topological order as described in \cite{PanL98}. The truth tables of the cuts are obtained as a by-product of the cut enumeration. Thus, when two fanin cuts are merged during the cut computation and the resulting cut is 3-feasible, the truth tables of fanin cuts are permuted to match the fanin order of the resulting cut. These truth tables are then ANDed or XORed, depending on the node type, to get the resulting truth table. For the case of 3-input cuts, a dedicated pre-computation reduces the runtime of truth table computation to a small fraction of that of cut enumeration.
62c62
< As soon as the XOR3 and MAJ3 pairs are detected, algebraic rewriting will be applied to the AIG network in a constrained topological order, in which each XOR3 and MAJ3 pair is considered as one element. This means that at one topological depth, whenever either XOR3 or MAJ3 node of a pair (or its complement) is rewritten, the subsequent rewritten node is of the other type. The AIG nodes with the same topological depth that do not belong to any pair are ordered in the decreasing order of their integer IDs. The algebraic rewriting ends when all elements in AIG network have been rewritten. The algorithm returns the extracted input signature. 
---
> As soon as the XOR3 and MAJ3 pairs are detected, algebraic rewriting will be applied to the AIG network in a constrained topological order, in which each XOR3 and MAJ3 pair is considered as one element. This means that at one topological depth, whenever either XOR3 or MAJ3 node of a pair (or its complement) is rewritten, the following rewriting element is of the other type. The AIG nodes with the same topological depth that do not exist in any pairs are ordered by their hashing value (in decreasing order). The algebraic rewriting ends when all elements in AIG network have been rewritten and the algorithm returns the extracted input signature. 
73c73
< \subsection{Detecting Redundant Polynomials}
---
> \subsection{Redundant Polynomial Determination}
75c75
< Significant simplification of algebraic polynomial construction can be achieved not only by performing algebraic rewriting using a reserve-topological order, as discussed above, but also by detecting redundant polynomials. For example, \textit{don't-care} polynomials and \textit{vanishing} polynomials are used for verifying sequential arithmetic circuits \cite{yu-isvlsi-16a}. These polynomials are generated by observing that the signals removed to make design more efficient, contain algebraic information that is needed to cancel algebraic terms of the remaining output bits in the design. For example, the polynomial associated with the most significant bit (MSB) of an adder or a multiplier is such a polynomial. Such truncated designs are widely used in energy efficient applications by reducing critical paths and pruning the logic. However, automatically generating the redundant polynomials has not been addressed so far. 
---
> In addition to the order of algebraic rewriting, identifying and using redundant polynomials could also provide significant polynomial reductions. For example, \textit{don't-care} polynomials and \textit{vanishing} polynomials are used for verifying sequential arithmetic circuits \cite{yu-isvlsi-16a}. Those polynomials are generated by observing that the signals that are removed for design efficiency contain algebraic information that is needed to cancel algebraic terms of the remaining output bits in the design. For example, the polynomial associated with the most significant bit (MSB) of an adder or a multiplier is such a polynomial. Such truncated designs are widely used in energy efficient applications by reducing critical paths and pruning the logic. However, automatically generating the redundant polynomials has not been adequately solved yet. 
80c80
< To efficiently apply algebraic rewriting to the multipliers with output bits truncated, an approach that automatically generates \textit{don't-care} polynomials is presented. This approach is based on an observation that the logic obtained by removing output bits is either a carry-out function or a sum function of a 1-bit adder. It is known that MAJ3 and XOR3 are the components of a 1-bit adder. Hence, using the approach of detecting pairs of XOR3 and MAJ3 (Section \rom{3}-A), the XOR3/MAJ3 nodes that do not belong to any such pairs are also identified. For example, a $n$-bit CSA-multiplier with \textit{2n-1} output bits (with MSB removed), there is a missing MAJ3, i.e., the MAJ3s with identical inputs of an unpaired XOR3. Since one pair of XOR3 and MAJ3 is a 1-bit adder, removing the carry bit (MAJ3) makes the function an addition \textit{modulo 2}. In this case, the algebraic model of XOR3 (Equation 1) is reduced to \textit{a $\oplus$ b $\oplus$ c = a+b+c mod 2}. %The negation of the removed terms by modulo 2, $- 2ac - 2bc + 4abc$, gives the redundant polynomials detected for each unpaired XOR3. 
---
> To efficiently apply algebraic rewriting to the multipliers with output bits truncated, an approach that automatically generates \textit{don't-care} polynomials is presented. This approach is based on an observation that the logic obtained by removing output bits is either a carry-out function or a sum function of one-bit addition. It is known that MAJ3 and XOR3 are the components that construct a 1-bit addition. Hence, using the approach of detecting pairs of XOR3 and MAJ3 (Section \rom{3}-A), the XOR3/MAJ3 nodes that do not belong to any such pair can be detected. For example, a $n$-bit CSA-multiplier with \textit{2n-1} output bits (with MSB removed), there is a missing MAJ3, i.e., the MAJ3s with identical inputs of an unpaired XOR3. Since one pair of XOR3 and MAJ3 constructs a 1-bit addition, removing the carry bit (MAJ3) makes the function an addition \textit{modulo 2}. In this case, the algebraic model of XOR3 (Equation 1) is reduced to \textit{a $\oplus$ b $\oplus$ c = a+b+c mod 2}. %The negation of the removed terms by modulo 2, $- 2ac - 2bc + 4abc$, gives the redundant polynomials detected for each unpaired XOR3. 
82c82
< \textbf{Example 2 (3-bit CSA-multiplier with MSB $z_{5}$ detected):} The AIG after detecting XOR3 and MAJ3 pairs of a 3-bit post-synthesized CSA-multiplier with MSB deleted is shown in Figure \ref{fig:3-bit-aig}. The detected XOR3 and MAJ3 pairs are represented using the ID of the root node of the XOR3 and MAJ3 nodes. We can see that there is one XOR3 (composed of two XOR2 nodes, \textit{41} and \textit{44}) with inputs $i_{36,37}$, $i_{27,29}$ and $i_{38}$, that cannot be paired with any MAJ3. This is because synthesis process removed the redundant logic (last carry out) while the MSB has been removed. In this case, the algebraic model of that XOR3 is reduced to $2^{4}$$\cdot$$z_{4}$($i_{49}$) = $2^4$$\cdot$($i_{36,37}$ + $i_{27,29}$ + $i_{38}$).
---
> \textbf{Example 2 (3-bit CSA-multiplier with MSB $z_{5}$ detected):} The AIG after detecting XOR3 and MAJ3 pairs of a 3-bit post-synthesized CSA-multiplier with MSB deleted is shown in Figure \ref{fig:3-bit-aig}. The detected XOR3 and MAJ3 pairs are represented using the hash value of the root node of the XOR3 and MAJ3 nodes. We can see that there is one XOR3 (composed of two XOR2 nodes, \textit{41} and \textit{44}) with inputs $i_{36,37}$, $i_{27,29}$ and $i_{38}$, that cannot be paired with any MAJ3. This is because synthesis process removed the redundant logic (last carry out) while the MSB has been removed. In this case, the algebraic model of that XOR3 is reduced to $2^{4}$$\cdot$$z_{4}$($i_{49}$) = $2^4$$\cdot$($i_{36,37}$ + $i_{27,29}$ + $i_{38}$).
105d104
< 
