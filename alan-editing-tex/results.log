3,4c3,4
< The technique described in this paper was implemented in ABC \cite{abc-link}. It applies algebraic rewriting to the AIG and generates the polynomial signature. The experiments include gate-level rewriting of Carry-Save-Adder (CSA) multipliers up to 512 bits. The results are compared with \textit{functional extraction} \cite{ciesielski2015verification}.
< The results show that the proposed technique is more efficient than the state-of-the-art technique for extracting the polynomial expressions for the CSA multipliers. The experiments were conducted on a PC with Intel(R) Xeon CPU E5-2420 v2 2.20 GHz x12 with 32 GB memory.
---
> The technique described in this paper was implemented in C, and embedded in the ABC system\cite{abc-link}. It applies algebraic rewriting on AIG network and generates the polynomial signature. The experimental results include rewriting on gate-level Carry-save-adder (CSA) multipliers up to 512-bit, and compared to \textit{function extraction} \cite{ciesielski2015verification}.
> They show that our technique is more efficient than the state-of-the-art technique in extracting the polynomial expressions of CSA multipliers. The experiments were conducted on a PC with Intel(R) Xeon CPU E5-2420 v2 2.20 GHz x12 with 32 GB memory.
6c6
< The results of applying AIG-based algebraic rewriting to pre-synthesized and post-synthesized CSA multipliers are shown in Table \ref{tbl:pre} and Table \ref{tbl:post}, respectively. The gate-level multipliers are taken from \cite{ciesielski2015verification}. Runtime and memory usage of \textit{functional extraction} \cite{ciesielski2015verification} are shown in columns 2 and 3, and the results of the proposed approach are shown in columns 4 and 5. The bit-width varies between 8 and 256 bits\footnote{512-bit post-synthesized multipliers are not reported in \cite{ciesielski2015verification}.}. First, we can see that the runtime of the proposing approach is lower than a second for both the pre- and post-synthesized CSA multipliers for any bit-width. At the same time, memory usage has been reduced on average 60\%, compared to \textit{function extraction} \cite{ciesielski2015verification}. Finally, the complexity of extracting the polynomial expression using functional extraction is increased when the multipliers are synthesized. For example, extracting post-synthesized 256-bit multiplier using functional extraction requires 9x more runtime and more memory. However, using the proposed approach, the runtime of extracting pre- or post-synthesized multipliers are almost the same.
---
> The results of applying AIG-based algebraic rewriting on pre-synthesized and post-synthesized CSA-multipliers are shown in Table \ref{tbl:pre} and Table \ref{tbl:post}. The gate-level multipliers are taken from \cite{ciesielski2015verification}. Runtime and memory usage of \textit{function extraction} \cite{ciesielski2015verification} are shown in columns 2 and 3, and the results of the described approach are shown in columns 4 and 5. The bit-width varies from 8 to 256 bits\footnote{512-bit post-synthesized multipliers was not reported in \cite{ciesielski2015verification}.}. First, we can see that the runtime of the proposing approach is lower than a second on both the pre- and post-synthesized CSA-multipliers from 8-bit to 256-bit. At the same time, the memory usage has been reduced on average 60\% compared to \textit{function extraction} \cite{ciesielski2015verification}. Finally, the complexity of extracting the polynomial expression using function extraction is increased while the multipliers have been synthesized. For example, extracting post-synthesized 256-bit multiplier using function extraction requires 9x more runtime and more memory. However, using the proposed approach, the runtime of extracting pre- or post-synthesized multipliers are almost the same.
11c11
< %\input{../table/booth-mult.tex}
---
> %\input{../table/booth-mult.tex}
\ No newline at end of file
